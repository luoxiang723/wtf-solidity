{
	"compiler": {
		"version": "0.8.30+commit.73712a01"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [
					{
						"internalType": "uint256[]",
						"name": "arr",
						"type": "uint256[]"
					},
					{
						"internalType": "uint256",
						"name": "target",
						"type": "uint256"
					}
				],
				"name": "search",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					},
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "pure",
				"type": "function"
			}
		],
		"devdoc": {
			"kind": "dev",
			"methods": {},
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {
				"search(uint256[],uint256)": {
					"notice": "二分查找: 给定一个有序数组，查找目标值是否存在，如存在则返回下标 0 8 =>4  5 5 8 =>6  7 [1,2,3,4,5,6,7,8,9]  0 1 2 3 4 5 6 7 8 7"
				}
			},
			"notice": "二分查找 (Binary Search) 题目描述：在一个有序数组中查找目标值。 确定初始搜索区间：将搜索范围初始化为整个数组，通常用两个指针 left和 right表示当前搜索区间的左右边界。 查找中间元素：计算中间位置的索引 mid。推荐使用 mid = left + (right - left) / 2来计算， 这样可以避免直接相加 (left + right)可能导致的整数溢出问题 。 比较与判断： 如果 arr[mid]等于目标值 target，则查找成功。 如果 arr[mid]小于 target，说明目标值只可能存在于 mid的右侧，因此将 left移动到 mid + 1。 如果 arr[mid]大于 target，说明目标值只可能存在于 mid的左侧，因此将 right移动到 mid - 1。 循环或递归：重复步骤2和3，直到找到目标值或搜索区间变为空（即 left > right）。",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"BinarySearch.sol": "BinarySearch"
		},
		"evmVersion": "prague",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"BinarySearch.sol": {
			"keccak256": "0x7270a78e0d7eb4ace976c9bc4de218a8523b381985240018611e93432a042449",
			"urls": [
				"bzz-raw://b1871f00b3be37dbdd0920c18a5be5ee848dd467f9a5ad4312467abf658e4c1d",
				"dweb:/ipfs/QmXSeJjbLXaq2sqcgRzERs1MpGSoDvVijSfYxCXrR8ozWv"
			]
		}
	},
	"version": 1
}